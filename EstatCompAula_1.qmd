---
format: 
  revealjs:
    theme: ["theme/q-theme.scss"]
    slide-number: c/t
    #logo: "https://www.faest.icen.ufpa.br/images/110.png"
    footer: "[https://github.com/paulocerqueirajr](https://https://github.com/paulocerqueirajr)"
    code-copy: true
    center-title-slide: false
highlight-style: a11y
code-link: true
height: 1080
width: 1600
execute: 
  eval: true
  echo: true
---

<h1> Estat√≠stica Computacional </h1>

<h2> Simula√ß√£o de vari√°veis aleat√≥rias - Parte 1 </h2>

<hr>

<br>

<h3> Prof. Paulo Cerqueira Jr <br>
Faculdade de Estat√≠stica - FAEST <br> 
Programa de P√≥s-gradua√ß√£o em Matem√°tica e Estat√≠stica - PPGME </h3>

<h3>  </h3>
<br>

<h3> [https://github.com/paulocerqueirajr](https://https://github.com/paulocerqueirajr)

![](github.jpg){.absolute top=560 left=845 height="80"}



![](ppgme.jpg){.absolute top=5 left=1400 height="200"}

<!-- ![](https://www.faest.icen.ufpa.br/images/110.png){.absolute top=5 left=1400 height="200"} -->


# [Introdu√ß√£o]{style="float:right;text-align:right;"} {background-color="#027eb6"}


## Introdu√ß√£o


> Estat√≠stica computacional envolve transformar teoria e m√©todos em algoritmos e c√°lculos num√©ricos reais com dados. 

* Trata-se de resolver problemas computacionais reais que surgem quando visualizamos, analisamos e modelamos dados.


* A **estat√≠stica computacional** n√£o √© um t√≥pico √∫nico e coerente, mas sim um grande n√∫mero de t√©cnicas computacionais vagamente relacionadas que usamos em estat√≠stica. 

* Em vez disso, alguns t√≥picos e metodologias estat√≠sticas selecionados s√£o tratados com algum detalhe. 

* Pretende-se que boas pr√°ticas computacionais possam ser aprendidas a partir desses t√≥picos e transferidas para outras metodologias estat√≠sticas conforme necess√°rio. 



## Introdu√ß√£o

* Esta disciplina √© inteiramente dedicada √† exposi√ß√£o de m√©todos para simula√ß√£o de
vari√°veis aleat√≥rias. 

* A discuss√£o dos algoritmos ser√° fundamentada pela Teoria das
Probabilidades. 

* Algumas aplica√ß√µes ser√£o desenvolvidas ao final desta unidade tais como: 

  - Gera√ß√£o de vari√°veis uniformes e n√£o uniformes;
  - Integra√ß√£o Monte Carlo.


## Introdu√ß√£o


> Simula√ß√£o computacional significa usar um computador para recriar modelos matem√°ticos de sistemas ou processos em diferentes cen√°rios. 


* As simula√ß√µes podem ser determin√≠sticas ou estoc√°sticas.



## Introdu√ß√£o

> Por que √© necess√°rio saber gerar vari√°veis aleat√≥rias?

. . .

* Gerar bancos de dados para avaliar o desempenho de modelos propostos;

* Aproximar integrais. Ex.: algoritmo EM Monte Carlo;

* Estat√≠stica Bayesiana: Gerar amostras da distribui√ß√£o a posteriori quando a mesma n√£o tem express√£o fechada conhecida para sua fun√ß√£o de densidade ou fun√ß√£o massa de probabilidade.

. . .

## Exemplo de Simula√ß√£o determin√≠stica



* Considere o problema de condu√ß√£o de calor numa chapa met√°lica quadrada. 

* Para simular este sistema √© necess√°rio resolver a seguinte equa√ß√£o diferencial
parcial

$$k\dfrac{\partial T(x,y,t)}{\partial t}.$$

sujeita √†s condi√ß√µes de contorno nas bordas da chapa.



## Exemplo de Simula√ß√£o estoc√°stica



* Suponha que clientes chegam para utilizar um certo servi√ßo e s√£o
atendidos por $k$ servidores onde $k$ √© um inteiro positivo. 

* Suponha que os tempos entre chegadas sucessivas de clientes s√£o vari√°veis aleat√≥rias exponencialmente distribu√≠das com taxa $\lambda$ e que o tempo de servi√ßo prestado a cada cliente √© uma
vari√°vel aleat√≥ria exponencialmente distribu√≠da com taxa $\mu$. 

* Al√©m disso, suponha que tempos de servi√ßo associados a clientes distintos s√£o independentes. Quando existem mais de $k$ clientes no sistema, o excesso forma um fila de espera at√© que um
deles seja chamado por um dos servidores. 

:::info-box
Eventualmente estaremos interessados em responder quest√µes tais como:

  - Quais cen√°rios (valores de $\lambda$, $\mu$ e $k$) s√£o capazes de produzir longas filas?
  - Qual √© o n√∫mero m√©dio de clientes no sistema?
  - Qual √© o tempo m√©dio gasto por um cliente no sistema?
:::

# [Simula√ß√£o de N√∫meros Pseudo-Aleat√≥rios]{style="float:right;text-align:right;"} {background-color="#027eb6"}


## Simula√ß√£o de N√∫meros Pseudo-Aleat√≥rios

* Antigamente n√∫meros aleat√≥rios eram gerados mecanicamente ou manualmente, usando roletas, urnas, moedas ou dados. 

* A abordagem moderna consiste em usar um computador para gerar uma sequ√™ncia de n√∫meros que para todos os fins pr√°ticos imita uma amostra aleat√≥ria simples de uma uniforme no intervalo $(0, 1)$.

* Na verdade, estes n√∫meros s√£o apenas pseudo-aleat√≥rios pois, como veremos, eles s√£o gerados de forma determin√≠stica.

* Obviamente isto pode trazer d√∫vidas quanto a efici√™ncia de tais geradores como fontes de aleatoriedade. Por√©m a discussÀúao
deste tema √© dif√≠cil e foge completamente do escopo do curso.

* Vamos assumir simplesmente que os algoritmos que ser√£o apresentados produzem uma sequ√™ncia de vari√°veis aleat√≥rias i.i.d. uniformemente distribu√≠das no intervalo $(0, 1)$.


# [Opera√ß√£o $x\ \text{mod}\ n$]{style="float:right;text-align:right;"} {background-color="#027eb6"}



## Opera√ß√£o $x\ \text{mod}\ n$


Seja $n \in \mathbb{Z}$ e defina uma rela√ß√£o $R$ em $\mathbb{Z}$ tal como segue
$$xRy\ \text{se, e somente se,} \ x-y=kn, \ k \in \mathbb{Z}$$
A classe de equival√™ncia de $y\in \mathbb{Z}$ √© definida pelo conjunto,
$$\bar{y}=\{x \in \mathbb{Z}; xRy\}=\{x \in \mathbb{Z}; x=kn+y, k\in \mathbb{Z}\}.$$

A rela√ß√£o $R$ induz uma parti√ß√£o em $\mathbb{Z}$ tal como segue
$$\mathbb{Z}=\bar{0}\cup \bar{1}\cup \bar{2}\cup \dots \cup \overline{n-1}.$$

## Opera√ß√£o $x\ \text{mod}\ n$

Ou seja,


$$
\left\{
\begin{array}{l}
\bar{0}=\{x \in \mathbb{Z}; x=kn, k\in \mathbb{Z}\}=\{\dots, -2n, -n, 0, n, 2n, \dots\}\\
\bar{1}=\{x \in \mathbb{Z}; x=kn+1, k\in \mathbb{Z}\}=\{\dots, -2n+1, -n+1, 1, n+1, 2n+1, \dots\}\\
\bar{2}=\{x \in \mathbb{Z}; x=kn+2, k\in \mathbb{Z}\}=\{\dots, -2n+2, -n+2, 2, n+2, 2n+2, \dots\}\\
\vdots\\
\overline{n-1}=\{x \in \mathbb{Z}; x=kn+n, k\in \mathbb{Z}\}=\{\dots, -n, -1, -1, n-1, 2n-1, \dots\}\\
\end{array}
\right.
$$

Note que, $\bar{n}=\bar{0}$, $\overline{n+1}=\bar{1}$, etc.



## Opera√ß√£o $x\ \text{mod}\ n$


A opera√ß√£o $x\ \text{mod}\ n$, $x \in \mathbb{Z}$ e $n \in \mathbb{Z}$, √© definida por



$$
x \ \text{mod} \ n=
\left\{
\begin{array}{ll}
0 & x \in \bar{0}\\
1 & x \in \bar{1}\\
2 & x \in \bar{2}\\
\vdots & \vdots \\
n-1 & x \in \overline{n-1}\\
\end{array}
\right.
$$




## Exemplo $x\ \text{mod}\ n$


Como exemplo, vejamos a opera√ß√£o $x \ \text{mod} \ 4$:

$$
x \ \text{mod}\ 4=
\left\{
\begin{array}{ll}
0 & x \in \bar{0}=\{\dots,-8,-4,0,4, 8, \dots\}\\
1 & x \in \bar{1}=\{ \dots, -7, -3, 1, 5, 9, \dots \}\\
2 & x \in \bar{2}=\{ \dots, -6, -2, 2, 6, 10, \dots \}\\
3 & x \in \bar{3}=\{ \dots, -5, -1, 3, 7, 11, \dots\}\\
\end{array}
\right.
$$



## No `R`

No `R` a opera√ß√£o $x \ \text{mod}\ n$ √© realizada com o operador `%%`.

```{r, message=TRUE, warning=FALSE, echo=TRUE, comment=""}
8%%4 # resto de divis√£o 8/4

11%%4 # resto de divis√£o 11/4

2%%4 # resto de divis√£o 2/4

-3%%4 # resto de divis√£o -3/4
```


# [M√©todo Congruencial Linear]{style="float:right;text-align:right;"} {background-color="#027eb6"}

## M√©todo Congruencial Linear

* Sejam $a$, $b$ e $n$ inteiros positivos e seja $x_1$ um natural menor do que $n$. 


* Este m√©todo prop√µe uma sequ√™ncia de n√∫meros pseudo-aleat√≥rios gerada pela seguinte equa√ß√£o de recorr√™ncia:
$$x_{k+1}=(a x_{k}+b) \ \text{mod} \ n,$$

$k\geq 1$. Tal como foi definida $x_k\in \{0,1,\dots, n-1\}$ para todo $k\geq 1$. Portanto para obter uma sequ√™ncia $(u_k)_{k\geq 1}$ com valores em $(0, 1)$, basta fazer
$$u_k=\dfrac{x_k}{n}, \quad k\geq 1.$$


## Exemplo 1:

Fa√ßa $a = 123$, $b = 971$, $n = 1137$ e $x_1 = 27$.

\footnotesize

```{r, message=TRUE, warning=FALSE, echo=TRUE, comment=""}
x <- NULL
x[1] <- 27
for(k in 1:20){
  x[k+1] <- ((123*x[k] + 971) %% 1137)
}
u <- x/1137 # Seq. uniforme.
u 
```


<!-- ## Exemplo 2: -->


<!-- Fa√ßa $a = 6$, $b = 7$, $n = 5$ e $x_1 = 2$. -->
<!-- \footnotesize -->
<!-- ```{r, message=TRUE, warning=FALSE, echo=TRUE, comment=""} -->
<!-- x <- NULL -->
<!-- x[1] <- 2 -->
<!-- for(k in 1:20){ -->
<!--   x[k+1] <- ((6*x[k] + 7) %% 5) -->
<!-- } -->
<!-- u <- x/5 # Seq. uniformes. -->
<!-- u -->
<!-- ``` -->


## Exemplo: Ciclos per√≥dicos


Certas escolhas dos valores de $a$, $b$ e $n$, podem gerar sequ√™ncias com ciclos peri√≥dicos.


Fa√ßa $a = 6$, $b = 7$, $n = 5$ e $x_1 = 2$.

\footnotesize
```{r, message=TRUE, warning=FALSE, echo=TRUE, comment=""}
x <- NULL
x[1] <- 2
for(k in 1:12){
  x[k+1] <- ((6*x[k] + 7) %% 5)
}
x
u <- x/5
u
```



## Exemplo: Ciclos per√≥dicos


Fa√ßa $a = 1$, $b = 1$, $n = 10$ e $x_1 = 3$.

\footnotesize
```{r, message=TRUE, warning=FALSE, echo=TRUE, comment=""}
x <- NULL
x[1] <- 3
for(k in 1:15){
  x[k+1] <- ((x[k] + 1) %% 10)
}
x
u <- x/10
u
```


## Exemplo


Algumas boas receitas:

* $x_{k+1}=(44485709377909 x_k + 375)\ \text{mod} \ 248$;

* $x_{k+1} = (16807 x_{k} + 8437)\ \text{mod} \ (231-1)$.


## Semente

\footnotesize

* No programa ``R`` podemos gerar n√∫meros aleat√≥rios uniformes cont√≠nuos utilizando uma
fun√ß√£o pr√©-programada. 

* Os n√∫meros aleat√≥rios uniformes s√£o gerados pelo comando ``runif(n, min, max)``, em que:
  - ``n`` √© o tamanho da sequ√™ncia;
  - ``min`` e ``max`` s√£o argumentos que delimitam o valor m√≠nimo e m√°ximo da sequ√™ncia a ser gerada. 
  
* O controle da semente para se gerar uma sequ√™ncia reproduz√≠vel de n√∫meros uniformes √© dada pelo comando ``set.seed(semente)``, onde o argumento ``semente`` deve ser um n√∫mero inteiro. 

* O R automaticamente determina a cada chamada uma nova
semente. 



## Semente


Conseguimos gerar diferentes sequ√™ncias em cada chamada do comando `runif(n, min, max)`, sem nos preocuparmos com a semente aleat√≥ria. 

Devemos reiterar que o programa `R`  oferece seis geradores de eventos uniformes:


**Wichmann-Hill** De per√≠odo aproximado $7\times10^{12}$.

**Marsaglia-Multicarry** De per√≠odo aproximadamente igual a $2^{60}$, passa em testes rigorosos.


**Super-Duper** De per√≠odo aproximado $5\times10^{18}$, n√£o passa em alguns testes rigorosos.

**Mersenne-Twister** De per√≠odo $2^{19937}-1$ e boa distribui√ß√£o em espa√ßos de dimens√µes inferiores a $623$. (_default_ !)

**Knuth-TAOCP** Este gerador √© definido pela rela√ß√£o $u_{j}=(u_{j-100}-u_{j-37})\ \text{mod} \ 2^{30}$ e seu periodo √© de aproximadamente $2^129$.

\textbf{Knuth-TAOCP-2002} Uma vers√£o atualizada e melhorada do anterior.


## Uniformes no `R`

Usando a fun√ß√£o do R para gerar valores de uma uniforme (`runif`):



```{r, message=TRUE, warning=FALSE, echo=TRUE, comment=""}

(x <- runif(n=10, min=0, max=1))

(x <- runif(n=10, min=1, max=2))

(x <- runif(n=10, min=-1, max=1))
```


# [M√©todo da Transforma√ß√£o Inversa]{style="float:right;text-align:right;"} {background-color="#027eb6"}


## M√©todo da Transforma√ß√£o Inversa

Seja $X$ uma v.a. com fun√ß√£o de distribui√ß√£o acumulada $F$ cont√≠nua. Seja $F^{-1}:(0, 1)\rightarrow \mathbb{R}$ uma fun√ß√£o definida por

$$F^{-1}(u)=\inf \{ x \in \mathbb{R}: F(x)\geq u \}.$$

A fun√ß√£o $F^{-1}$ √© a fun√ß√£o generalizada de $F$.

> Proposi√ß√£o 1: $U=F(X)\sim U(0,1)$ 

> Proposi√ß√£o 2: seja $U\sim U(0,1)$ e seja $X$ uma v.a. com fun√ß√£o de distribui√ß√£o acumulada $F$ cont√≠nua. Ent√£o, $F^{-1}(U)\sim F$, ou seja, $X$ possui a mesma distribui√ß√£o que $F^{-1}(U)$.


## Graficamente

<!-- \centering -->

<!-- \begin{figure} -->
<!-- \label{fig1} -->
<!-- \scalebox{0.7}{\includegraphics{MTI.png}} -->
<!-- \caption{Exemplo do m√©todo da fun√ß√£o de distribui√ß√£o inversa.} -->
<!-- \end{figure} -->


![](MTI.png){fig-alt="Gr√°fico da fun√ß√£o de distrribui√ß√£o." fig-align="center" width=10%}


## Simula√ß√£o de $X\sim Exp(1)$.


* Temos que a fun√ß√£o de distribui√ß√£o √© $F(x)=1-e^{-x}$. 

* Logo, usando o m√©todo da transforma√ß√£o inversa temos que,

$$u=F(x) \Leftrightarrow u= 1-e^{-x} \Leftrightarrow 1-u=e^{-x}.$$

$$\log(1-u)=-x \Leftrightarrow x=-\log(1-u).$$

Assim, $X=-\log(1-U)\sim Exp(1)$, em que $U\sim Unif(0,1)$.



## Exemplo

> Simula√ß√£o de $X\sim Exp(1)$.

Vamos gerar 10 valores de uma distribui√ß√£o exponencial com taxa 1:


::: columns
:::: column
```{r, message=TRUE, warning=FALSE, echo=TRUE, comment=""}
u <- runif(10,0,1)
x <- -log(1-u)
summary(x)
```

::::
:::: column

\footnotesize
```{r, message=TRUE, warning=FALSE, echo=TRUE, comment="", fig.align='center'}
hist(x, main="", border=FALSE, 
     freq = FALSE)
aux <- seq(0,10, length.out=1000)
lines(aux, dexp(x=aux, rate = 1), 
      col="red")
```
::::
:::


## Simula√ß√£o de $X\sim Exp(1)$.


Vamos gerar 500 valores de uma distribui√ß√£o exponencial com taxa 1:



::: columns
:::: column


```{r figec1, message=TRUE, warning=FALSE, echo=TRUE, comment=""}
u <- runif(500,0,1)
x <- -log(1-u)
summary(x)
```

::::
:::: column


```{r figec2, message=TRUE, warning=FALSE, echo=TRUE, comment=""}
hist(x, main="", border=FALSE, 
     freq = FALSE)
aux <- seq(0,10, length.out=1000)
lines(aux, dexp(x=aux, rate = 1), 
      col="red")
```
::::
:::



## M√©todo da transforma√ß√£o inversa


:::{.callout-tip}
## Algoritmo gen√©rico:

1. Obtenha a fun√ß√£o $F^{-1}$, ou seja, obtenha a inversa generalizada de $F$ (onde $F$ representa a fun√ß√£o de distribui√ß√£o de $X$);

2. Simule $U \sim U(0,1)$;

3. Fa√ßa $X=F^{-1}(U)$. A proposi√ß√£o 2 garante que $X\sim F$.

:::

. . . 

:::{.callout-warning}
## Aviso:

* E se $F$ n√£o possuir fun√ß√£o inversa de forma anal√≠tica?

* Como resolver?

:::

. . .

## M√©todo da transforma√ß√£o inversa


* Precisamos lembrar da seguinte rela√ß√£o do m√©todo:

$u=F(x)\ \Rightarrow \ F(x)-u=0$

* Observe que $F(x)-u=0$ √© uma fun√ß√£o em que a raiz √© $x$.

* Dessa forma, podemos usar m√©todos de otimiza√ß√£o num√©rica no caso univariado.


## Exemplo - Modelo $N(0,1)$

* Sabemos por defin√ß√£o do modelo que 


$$F(x)=\int\limits_{-\infty}^{\infty}\dfrac{1}{\sqrt{2\pi}}\exp \left\{ -0.5X  \right\}dx.$$

* Neste caso, s√≥ conseguiremos resolver, mudando as coordenadas ou atrav√©s de algum m√©todo num√©rico de integra√ß√£o.

* No `R`:

```{r}
## Fun√ß√£o para otimizar
f <- function(x, u){
  pnorm(x, 0, 1) - u
}

```

## Exemplo - Modelo $N(0,1)$

:::{.callout-tip}
## Fun√ß√£o de otimiza√ß√£o:

* No `R` dispomos de diversar fun√ß√µes para encontrar raiz ded fun√ß√µes univariadas.

* Usaremos a fun√ß√£o `uniroot` como proposta.

:::

* Logo, para gerar um valor da vari√°vel $X$:

```{r}
uniroot(f, interval = c(-5, 5), 
        u=runif(1))
```


## Exemplo - Modelo $N(0,1)$


:::columns
::::column
* Para gerar uma amostra de tamanho $n$ basta fazer:

```{r}
n <- 1000
amostra <- vector(mode = "numeric", 
                  length = n)

for(i in 1:n){
  amostra[i]  <- uniroot(f, 
                    interval = c(-5, 5),
                         u=runif(1))$root
}
```
::::
::::column

* Avaliando o histograma com os dados gerados:

```{r}
require(ggplot2)
dados <- as.data.frame(amostra)
ggplot(dados, aes(x=amostra))+
  geom_histogram(aes(y=..density..),
                 colour="black", 
                 fill="white")
```
::::
:::




# [M√©todo da Aceita√ß√£o/Rejei√ß√£o]{style="float:right;text-align:right;"} {background-color="#027eb6"}

## M√©todo da Aceita√ß√£o/Rejei√ß√£o



* Seja $X$ uma v.a. cont√≠nua com densidade $g$ e assuma que existe um m√©todo para simular de $g$. 

* √â poss√≠vel usar este m√©todo como base para simular de uma outra v.a. cont√≠nua $Y$ com densidade $f$. 

* A id√©ia fundamental √© inicialmente gerar $X$ de $g$ e ent√£o aceitar o valor gerado, com probabilidade
proporcional a $f(X)/g(X)$, com sendo uma valor gerado de $f$. 

* Este m√©todo √© chamado de aceita√ß√£o/rejei√ß√£o (A-R).


## M√©todo da Aceita√ß√£o/Rejei√ß√£o

:::{.callout-tip}
## Algor√≠tmo gen√©rico:

1. Simule $X\sim g$ e $U\sim U(0,1)$;

2. Fa√ßa $Y=X$ se $U\leq f(X)/cg(X)$. Caso contr√°rio, volte ao passo anterior.
:::


* A constante $c$ √© tal que $f(X)\leq cg(X)$ para todo $x$ no suporte de $f$ e $g$.


* A fun√ß√£o $cg$ √© chamada de envelope.



## Graficamente


<!-- \begin{figure} -->
<!-- \scalebox{1}{\includegraphics{MAR.png}} -->
<!-- \caption{Envelope de $f$ por $cg$.} -->
<!-- \end{figure} -->


![](MAR.png){fig-alt="Gr√°fico da fun√ß√£o de distribui√ß√£o." fig-align="center" width=10%}




## M√©todo da Aceita√ß√£o/Rejei√ß√£o


:::{.callout-tip}
## Proposi√ß√µes

1. O algoritmo acima produz uma v.a. com distribui√ß√£o $f$.

2. Seja $\tau$ o n√∫mero de itera√ß√µes do algoritmo necess√°rias para produzir
um valor $Y$ com distribui√ß√£o $f$. Ent√£o

$$\tau\sim Geo(1/c), \ \text{com} \ E(\tau)=c.$$
:::


## M√©todo da aceita√ß√£o/rejei√ß√£o

:::{.callout-tip}
## Exerc√≠cio
Seja $Y\sim f(x)=12x^2(1-x),\ 0<x<1$. Utilize o m√©todo da aceita√ß√£o-rejei√ß√£o para simular 1000 valores de $f$.
:::

> Solu√ß√£o:

* Note que $X\sim U(0,1)$. Como esta vari√°vel pertence ao intervalo (0,1), podemos considerar o m√©todo com $g(x)=1$, para $x\in(0,1)$, i.e, uma distribui√ß√£o uniforme. 


* Para determinar o menor valor de $c$ tal que $f(x)/g(x)\leq c$, maximizamos 
$$\dfrac{f(x)}{g(x)}=12x^2(1-x)$$


* Temos que a derivada da express√£o anterior e igualada a zero √© $2x-3x^2=0$. Temos que o valor de x que maximiza √© $x=2/3$.

## Exemplo

Assim, $f(x)/g(x)\leq 12(2/3)^{2}(1/3)=16/9=c$. Logo, temos que 

$$\dfrac{f(x)}{c \ g(x)}=\dfrac{9}{16}12 x^{2}(1-x)=\dfrac{27}{9}x^{2}(1-x).$$

Assim, para este exemplo o algoritmo fica:

1. Gere $x$ e $u$ com distribui√ß√£o $U(0,1)$;

2. Se $u \leq \dfrac{27}{4}x^{2}(1-x)$, aceite o valor $Y=x$. Caso contr√°rio, retorne o passo 1.



## Exemplo


::: columns
:::: column
\scriptsize

```{r, echo=TRUE, warning=FALSE, message=FALSE, comment=""}


#gerando os valores que podem ser aceitos ou n√£o
x = runif(10000,0,1) 
aceito.val = c()

for(i in 1:length(x)){
  U = runif(1)
  if(U <= (27/4)*(x[i]^2)*(1-x[i])) {
    aceito.val[i] = 'Sim'
  }
  else{
    aceito.val[i] = 'N√£o'
  }
}  
T = data.frame(x, 
  aceito = factor(aceito.val,
                  levels= c('Sim','N√£o')))
head(T)



```


::::
:::: column


```{r , echo=TRUE, message=FALSE, warning=FALSE, comment=""}
require(ggplot2)
require(dplyr)
require(hrbrthemes)

fun.1 <- function(x) 12*(x^2)*(1-x)
```


```{r fig3, message=FALSE, warning=FALSE, echo=TRUE, comment=""}

ggplot(T, aes(x=x, fill=aceito))+
  geom_histogram(aes(y = ..density..), 
                 color="#e9ecef", 
            alpha=0.6, 
            position = 'identity') +
  scale_fill_manual(values=c("#69b3a2",
                             "#404080"))+
  stat_function(fun = fun.1) + 
  xlim(0,1)

```
::::
:::

# [Reamostragem ponderada]{style="float:right;text-align:right;"} {background-color="#027eb6"}

## Reamostragem ponderada


* O algoritmo sampling importance resampling (SIR) simula realiza√ß√µes aproximadas de alguma distribui√ß√£o alvo.

* Informalmente temos que:
   - Amostras s√£o geradas de uma fun√ß√£o de amostragem por import√¢ncia $g$.
   - Cada ponto na amostra √© ponderado para corrigir a probabilidade de amostragem de tal forma que a amostra ponderada seja relacionada da densidade alvo $f$.

## Reamostragem ponderada

* Para a densidade alvo $f$, os pesos usados para corrigir as probabilidades de amostragem s√£o chamados pesos de import√¢ncia padronizados e s√£o definidos por

$$\omega(x_{i})=\dfrac{f(x_{i})/g(x_{i})}{\sum^{m}_{i=1}f(x_{i})/g(x_{i}) },$$

para uma cole√ß√£o de valores $x_1,\dots, x_m$ gerados de $g$.


* Podemos ver este m√©todo como uma aproxima√ß√£o de $f$ por uma distribui√ß√£o discreta tendo massa $\omega(x_{i})$ em cada ponto observado $x_i$ para $i = 1, \dots ,m$.



## Reamostragem ponderada


:::{.callout-tip}
## Algoritmo gen√©rico:

1. Gere candidatos $Y_1, \dots ,Y_m$ iid de $g$.

2.  Calcule os pesos de import√¢ncia padronizados , $\omega(Y_{1}),\dots , \omega(Y_{m})$.

3.  Reamostre, com reposi√ß√£o, $X_1, \dots ,X_n$ de $Y_1, \dots ,Y_m$ com probabilidades $\omega(Y_{1}),\dots , \omega(Y_{m})$.
:::


A vari√°vel aleat√≥ria $X$ amostrada com o algoritmo SIR tem distribui√ß√£o que converge para $f$ quando $m\rightarrow \infty$.


## Considera√ß√µes:

*  $n/m \rightarrow 0$ para converg√™ncia em distribui√ß√£o da amostra e,
para n fixo, a converg√™ncia ocorre quando $m \rightarrow 1$.

* A toler√¢ncia m√°xima para a raz√£o $n/m$ depende da qualidade
da densidade $g$. Algumas vezes $n/m \leq 1/10$ √© suficiente para
resultar em uma reamostra que n√£o contenha muitas
replica√ß√µes de valores.

* O suporte de $g$ deve incluir todo o suporte de $f$ e $g$ deve ter
caudas mais pesadas que $f$, ou de forma mais geral, $g$ ser
escolhida garantindo que $f(x)/g(x)4 nunca cres√ßa demais.

* Se $g(x)$ est√° pr√≥ximo de zero em um local onde $f(x)$ √©
positivo, ent√£o um valor gerado desta regi√£o acontecer√°
muito raramente, mas quando isso acontecer receber√° um
enorme peso.

## Exemplo

> Sejam $ùëã$ e $ùëà$ vari√°veis aleat√≥rias independentes, $ùëã$ com distribui√ß√£o $N(0,1)$ e $ùëà$ com distribui√ß√£o $Uniforme(0,1)$. Dizemos que $ùëå = ùëã/ùëà$ tem distribui√ß√£o de Slash e sua fun√ß√£o densidade de probabilidade √© dada por
$$f(y)=\begin{cases}
			\dfrac{1-\exp{-y^2/2}}{y^2 \sqrt{2\pi}}, & \text{se $y\neq 0$}\\
      \dfrac{1}{2 \sqrt{2\pi}}, & \text{se $y= 0$}
		 \end{cases}$$


## Exemplo



:::columns
::::column
* Esta densidade tem caudas muito pesadas.


* Para entendermos melhor a vantagem do SIR, veja abaixo a gera√ß√£o de amostra da distribui√ß√£o Slash diretamente por transforma√ß√£o. Note que s√£o gerados alguns valores muito
at√≠picos.


```{r, message=FALSE, warning=FALSE, echo=TRUE, comment=""}

dslash <- function(y){
(y!=0)*(1-exp(-y^2/2))/(y^2*sqrt(2*pi)) +
    (y==0)*(1-exp(-y^2/2))/(y^2*sqrt(2*pi))
}

rslash <- function(n){
u <- runif(n)
x <- rnorm(n)
y <- x/u
return(y)
}

```
::::
::::column

```{r fig4, message=FALSE, warning=FALSE, echo=TRUE, comment=""}


x <- rslash(500)
hist(x, ylab = "Densidade", xlab = "x", 
     main = "", breaks = 30,
     prob = TRUE)

```

::::
:::


## Exemplo


* Agora ilustramos o uso do SIR, considerando:
  - Uso do SIR com proposta Slash para gerar da Normal padr√£o.
  - Uso do SIR com proposta Normal padr√£o para gerar da Slash.

* No `R`, temos:

:::columns
::::column

```{r, message=FALSE, warning=FALSE, echo=TRUE, comment=""}
## Para gerar de uma normal padrao com proposta slash
Pesos1 <- function(y){
df <- dnorm(y); dg <- dslash(y)
p <- df/dg
pesos <- p/sum(p)
}
rnorm_sir <- function(n, m){
y <- rslash(m)
pesos <- Pesos1(y)
amostra <- sample(x = y, size = n,
                  replace = TRUE,
                  prob = pesos)
return(amostra)
}
```


::::
::::column

```{r, message=FALSE, warning=FALSE, echo=TRUE, comment=""}
## Para gerar de uma slash com proposta normal padrao
Pesos2 <- function(y){
df <- dslash(y); dg <- dnorm(y)
p <- df/dg
pesos <- p/sum(p)
}
rslash_sir <- function(n, m){
y <- rnorm(m)
pesos <- Pesos2(y)
amostra <- sample(x = y, size = n, 
                  replace = TRUE,
                  prob = pesos)
return(amostra)
}
```


::::
:::



## Exemplo



:::columns
::::column


```{r, message=FALSE, warning=FALSE, echo=TRUE, comment=""}
n <- 5000
m <- 100000
amostra1 <- rnorm_sir(n, m)
amostra2 <- rslash_sir(n, m)
```


::::
::::column

```{r fig5, echo=FALSE, message=FALSE, warning=FALSE, comment="", eval=FALSE}
par(mar = c(4, 4, 3, 2), mfrow = c(2, 1))
hist(amostra1, prob = TRUE, main = "", xlab = "x",
col = "darkgoldenrod", breaks = 50, ylab = "Densidade" )
grid <- seq(-5, 5, by = 0.01)
densidade <- dnorm(grid)
lines(grid, densidade, col = 2, lty = 1, lwd = 2)
hist(amostra2, prob = TRUE, main = "", xlab = "x",
col = "aquamarine1", breaks = 50, xlim = c(-7,7), ylab = "Densidade")
grid <- seq(-7, 7, by = 0.01)
densidade <- dslash(grid)
lines(grid, densidade, col = 2, lty = 1, lwd = 2)
```

::::
:::

```{r fig6, echo=TRUE, message=FALSE, warning=FALSE, comment="",fig.align='center'}
par(mar = c(4, 4, 3, 2), mfrow = c(1, 2))
hist(amostra1, prob = TRUE, main = "", xlab = "x",
col = "darkgoldenrod", breaks = 50, ylab = "Densidade" )
grid <- seq(-5, 5, by = 0.01)
densidade <- dnorm(grid)
lines(grid, densidade, col = 2, lty = 1, lwd = 2)
hist(amostra2, prob = TRUE, main = "", xlab = "x",
col = "aquamarine1", breaks = 50, xlim = c(-7,7), ylab = "Densidade")
grid <- seq(-7, 7, by = 0.01)
densidade <- dslash(grid)
lines(grid, densidade, col = 2, lty = 1, lwd = 2)
```